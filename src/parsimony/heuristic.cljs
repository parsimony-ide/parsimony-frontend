(ns parsimony.heuristic
  "Heuristic queries"
  (:require [clojure.set :as set]
            [parsimony.dag :as dag]
            [parsimony.inference :as inference]
            [parsimony.asm.inference :as asm.inference]
            [parsimony.parser :as parser]
            [parsimony.asm.parser :as asm.parser]
            [parsimony.union-find :as uf]
            [parsimony.util :refer [cartesian-product flast vec-non-empty]]
            [parsimony.console :as console]))

(defn distinct-n [xs f n]
  (->> xs
       (group-by f)
       (vals)
       (into [] (mapcat (partial take n)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Query Engine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;------------------------------------------------------------------------------
;; CLJS
;;------------------------------------------------------------------------------

(defn- run-cljs-query [constraint-state query-state]
  (let [intersection-state (inference/intersect-constraint-states constraint-state query-state)
        shortest-paths (dag/shortest-paths (:table intersection-state)
                                           (inference/start-node intersection-state)
                                           (inference/end-node intersection-state))
        decoded-solutions (->> shortest-paths
                               (map (partial inference/decode-solution-path intersection-state))
                               (sort-by :raw))]
    #_(console/debug ::run-cljs-query {:constraint-state constraint-state
                                       :query-state query-state
                                       :intersection-state intersection-state
                                       :shortest-paths shortest-paths
                                       :decoded-solutions decoded-solutions})
    (distinct-n decoded-solutions :path 1)))

;;------------------------------------------------------------------------------
;; CPP
;;------------------------------------------------------------------------------

(defn- gen-constraint-codec
  "Generate a one-off codec to use for heuristic constraint encoding. WARNING:
   does not allow interoperation with asm.parser since codecs generated by this
   function do not contain all symbols defined in the parser and lexer"
  [cs]
  (asm.inference/extend-codec cs [] asm.parser/empty-codec))

(defn- run-cpp-query [cljs-constraint cljs-query]
  (let [codec (gen-constraint-codec [cljs-constraint cljs-query])
        cpp-constraint (asm.inference/cpp-init-constraint cljs-constraint codec)
        cpp-query (asm.inference/cpp-init-constraint cljs-query codec)
        cpp-intersect (asm.inference/intersect-constraint-states cpp-constraint cpp-query)
        cpp-solution (asm.inference/solve-shortest cpp-intersect)
        decoded-solutions (->> (asm.inference/decode-solution-paths cpp-solution codec)
                               (sort-by :raw))]
    (asm.inference/cpp-free cpp-constraint)
    (asm.inference/cpp-free cpp-query)
    (asm.inference/cpp-free cpp-intersect)
    (asm.inference/cpp-free cpp-solution)
    #_(console/debug ::run-cpp-query {:decoded-solutions decoded-solutions})
    (distinct-n decoded-solutions :path 1)))

;;------------------------------------------------------------------------------
;; run-query
;;------------------------------------------------------------------------------

(def ^:dynamic *run-query-fn* run-cljs-query)

(defn run-query [constraint query]
  (*run-query-fn* constraint query))

(defn- limit-result
  [result]
  (-> result
      (distinct-n :params 1)
      (vec-non-empty)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Query State Construction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- add-edge [g i j syms]
  (let [from [i]
        to [j]]
    (-> g
        (dag/add-edge [i] [j])
        (dag/add-edge-attr [i] [j] :syms syms))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; delimited-list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- -dlist-query-state [element-syms separator-syms]
  {:table
   (-> (dag/new-dag)
       (add-edge 0 1 element-syms)
       (add-edge 1 2 separator-syms)
       (add-edge 2 1 element-syms)
       #_(add-edge 0 99 element-syms)
       (add-edge 2 99 element-syms))
   :provenance [[-1 [:!QUERY! 0 99]]]})

(defn- -delimited-list [constraint-state]
  (let [all-syms (inference/all-syms constraint-state)
        terminal-syms (into #{}
                            (filter parser/terminal?)
                            all-syms)
        query-result (run-query constraint-state (-dlist-query-state all-syms terminal-syms))]
    #_(console/debug ::delimited-list {:all-syms all-syms
                                       :terminal-syms terminal-syms})
    (vec (for [{:keys [raw path]} (sort-by :raw query-result)
               :let [elem (apply set/intersection (take-nth 2 path))
                     sep (-> (apply set/intersection (take-nth 2 (next path)))
                             (set/difference elem))]
               :when (and (seq elem)
                          (seq sep))]
           {:type :delimited-list
            :raw raw
            :path path
            :params {:elem elem
                     :sep sep}}))))

(defn delimited-list [constraint-state]
  (limit-result (-delimited-list constraint-state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; undelimited-list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- -ulist-query-state [element-syms]
  {:table
   (-> (dag/new-dag)
       (add-edge 0 1 element-syms)
       (add-edge 1 99 element-syms)
       (add-edge 99 99 element-syms))
   :provenance [[-1 [:!QUERY! 0 99]]]})

(defn- -undelimited-list [constraint-state]
  (let [all-syms (inference/all-syms constraint-state)
        query-result (run-query constraint-state (-ulist-query-state all-syms))]
    #_(console/debug ::undelimited-list {:all-syms all-syms})
    (vec (for [{:keys [raw path]} (sort-by :raw query-result)
               :let [elem (apply set/intersection path)]
               :when (seq elem)]
           {:type :undelimited-list
            :raw raw
            :path path
            :params {:elem elem}}))))

(defn undelimited-list [constraint-state]
  (limit-result (-undelimited-list constraint-state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; enclosed-delimited-list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- -edlist-query-state [element-syms separator-syms left-syms right-syms]
  (let [catchall-syms (set/union element-syms separator-syms left-syms right-syms)]
    {:table
     (-> (dag/new-dag)
         #_(add-edge 0 1 catchall-syms)
         #_(add-edge 1 1 catchall-syms)
         #_(add-edge 1 2 left-syms)
         (add-edge 0 2 left-syms)
         (add-edge 2 3 element-syms)
         (add-edge 3 4 separator-syms)
         (add-edge 4 3 element-syms)
         (add-edge 4 5 element-syms)
         (add-edge 5 99 right-syms)
         #_(add-edge 99 99 catchall-syms))
     :provenance [[-1 [:!QUERY! 0 99]]]}))

(def encloser-pairs
  [["\\{" "\\}"]
   ["\\[" "\\]"]
   ["\\(" "\\)"]])

(def left-enclosers (into #{}
                          (map first)
                          encloser-pairs))

(def right-enclosers (into #{}
                           (map second)
                           encloser-pairs))

(defn- paired-syms [lexer]
  (let [regex-str-map (into {}
                            (for [[kw {:keys [regex-str]}] lexer]
                              [regex-str kw]))]
    (into #{}
          (for [[left right] encloser-pairs
                :let [left-sym (get regex-str-map left)
                      right-sym (get regex-str-map right)]
                :when (and left-sym right-sym)]
            [(parser/->terminal left-sym)
             (parser/->terminal right-sym)]))))

(defn- find-enclosing-pairs [paired left right]
  (let [prod-set
        (into #{}
              (map vec)
              (cartesian-product [left right]))]
    (set/intersection prod-set paired)))

(defn- find-edges
  ([raw query-dest-node]
   (find-edges raw nil query-dest-node))
  ([raw query-source-node query-dest-node]
   (vec (for [[i [from to]]
              (map-indexed vector (map vector raw (next raw)))
              :when (or (not query-source-node)
                        (= (last from) query-source-node))
              :when (or (not query-dest-node)
                        (= (last to) query-dest-node))]
          [i [from to]]))))

(defn- -enclosed-delimited-list [constraint-state lexer]
  (let [all-syms (inference/all-syms constraint-state)
        terminal-syms (into #{}
                            (filter parser/terminal?)
                            all-syms)
        -paired-syms (paired-syms lexer)
        left-syms (into #{} (map first -paired-syms))
        right-syms (into #{} (map second -paired-syms))]
    (when (and (seq left-syms)
               (seq right-syms))
      (let [query-result (run-query constraint-state
                                    (-edlist-query-state (set/difference all-syms
                                                                         left-syms
                                                                         right-syms)
                                                         terminal-syms
                                                         left-syms
                                                         right-syms))]
        #_(console/debug ::enclosed-delimited-list
                         {:all-syms all-syms
                          :terminal-syms terminal-syms
                          :paired-syms -paired-syms
                          :left-syms left-syms
                          :right-syms right-syms})
        (vec (for [{:keys [raw path]} (sort-by :raw query-result)
                  :let [[i first-edge] (first (find-edges raw 2))
                        [j last-edge] (first (find-edges raw 99))
                        relevant-path (->> path
                                           (drop i)
                                           (drop-last (- (count path)
                                                         (inc j))))
                        encloser (find-enclosing-pairs -paired-syms
                                                       (first relevant-path)
                                                       (last relevant-path))
                        inner-path (->> relevant-path
                                        (drop 1)
                                        (drop-last 1))
                        elem (apply set/intersection (take-nth 2 inner-path))
                        sep (-> (apply set/intersection (take-nth 2 (next inner-path)))
                                (set/difference elem))]
                  :when (and (seq elem)
                             (seq sep)
                             (seq encloser))]
              {:type :enclosed-delimited-list
               :raw raw
               :path path
               :params {;;:first-edge first-edge
                        ;;:last-edge last-edge
                        :elem elem
                        :sep sep
                        :encloser encloser}}))))))

(defn enclosed-delimited-list [constraint-state lexer]
  (limit-result (-enclosed-delimited-list constraint-state lexer)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; enclosed-undelimited-list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- -eulist-query-state [element-syms left-syms right-syms]
  (let [catchall-syms (set/union element-syms left-syms right-syms)]
    {:table
     (-> (dag/new-dag)
         #_(add-edge 0 1 catchall-syms)
         #_(add-edge 1 1 catchall-syms)
         #_(add-edge 1 2 left-syms)
         (add-edge 0 2 left-syms)
         (add-edge 2 3 element-syms)
         (add-edge 3 4 element-syms)
         (add-edge 4 4 element-syms)
         (add-edge 4 99 right-syms)
         #_(add-edge 99 99 catchall-syms))
     :provenance [[-1 [:!QUERY! 0 99]]]}))

(defn- -enclosed-undelimited-list [constraint-state lexer]
  (let [all-syms (inference/all-syms constraint-state)
        -paired-syms (paired-syms lexer)
        left-syms (into #{} (map first -paired-syms))
        right-syms (into #{} (map second -paired-syms))
        query-result (run-query constraint-state
                                (-eulist-query-state (set/difference all-syms
                                                                     left-syms
                                                                     right-syms)
                                                     left-syms
                                                     right-syms))]
    #_(console/debug ::enclosed-undelimited-list {:all-syms all-syms
                                                  :paired-syms -paired-syms
                                                  :left-syms left-syms
                                                  :right-syms right-syms})
    (vec (for [{:keys [raw path]} (sort-by :raw query-result)
               :let [[i first-edge] (first (find-edges raw 2))
                     [j last-edge] (first (find-edges raw 99))
                     relevant-path (->> path
                                        (drop i)
                                        (drop-last (- (count path)
                                                      (inc j))))
                     encloser (find-enclosing-pairs -paired-syms
                                                    (first relevant-path)
                                                    (last relevant-path))
                     inner-path (->> relevant-path
                                     (drop 1)
                                     (drop-last 1))
                     elem (apply set/intersection inner-path)]
               :when (and (seq elem)
                          (seq encloser))]
           {:type :enclosed-undelimited-list
            :raw raw
            :path path
            :params {;;:first-edge first-edge
                     ;;:last-edge last-edge
                     :elem elem
                     :encloser encloser}}))))

(defn enclosed-undelimited-list [constraint-state lexer]
  (limit-result (-enclosed-undelimited-list constraint-state lexer)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; expression
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- -expression-query-state [element-syms op-syms left-syms right-syms]
  {:table
   (-> (dag/new-dag)
       (add-edge 0 1 element-syms)
       (add-edge 1 2 op-syms)
       (add-edge 2 3 element-syms)
       (add-edge 3 2 op-syms)
       (add-edge 0 4 left-syms)
       (add-edge 4 5 element-syms)
       (add-edge 5 4 op-syms)
       (add-edge 5 1 right-syms)
       (add-edge 2 6 left-syms)
       (add-edge 6 7 element-syms)
       (add-edge 7 6 op-syms)
       (add-edge 7 3 right-syms)
       (add-edge 0 8 left-syms)
       (add-edge 8 9 element-syms)
       (add-edge 9 10 op-syms)
       (add-edge 10 11 element-syms)
       (add-edge 11 10 op-syms)
       (add-edge 11 3 right-syms))
   :provenance [[-1 [:!QUERY! 0 3]]]})

(def elem-query-edges #{[0 1]
                        [2 3]
                        [4 5]
                        [6 7]
                        [8 9]
                        [10 11]})

(def op-query-edges #{[1 2]
                      [3 2]
                      [5 4]
                      [7 6]
                      [9 10]
                      [11 10]})

(def left-query-edges #{[0 4]
                        [2 6]
                        [0 8]})

(def right-query-edges #{[5 1]
                         [7 3]
                         [11 3]})

(def op-descs
  [;; logical and
   {:regex-str "\\&\\&"
    :precedence 24
    :associativity :left}
   ;; logical or
   {:regex-str "\\|\\|"
    :precedence 24
    :associativity :left}
   ;; equals
   {:regex-str "\\=\\="
    :precedence 23
    :associativity :left}
   {:regex-str "=="
    :precedence 23
    :associativity :left}
   ;; not equals
   {:regex-str "\\!\\="
    :precedence 23
    :associativity :left}
   {:regex-str "\\!="
    :precedence 23
    :associativity :left}
   ;; less than
   {:regex-str "\\<"
    :precedence 22
    :associativity :left}
   ;; greater than
   {:regex-str "\\>"
    :precedence 22
    :associativity :left}
   ;; less than eq
   {:regex-str "\\<\\="
    :precedence 22
    :associativity :left}
   {:regex-str "\\<="
    :precedence 22
    :associativity :left}
   ;; greater than eq
   {:regex-str "\\>\\="
    :precedence 22
    :associativity :left}
   {:regex-str "\\>="
    :precedence 22
    :associativity :left}
   ;; left shift
   {:regex-str "\\<\\<"
    :precedence 21
    :associativity :left}
   ;; right shift
   {:regex-str "\\>\\>"
    :precedence 21
    :associativity :left}
   ;; add
   {:regex-str "\\+"
    :precedence 20
    :associativity :left}
   ;; subtract
   {:regex-str "\\-"
    :precedence 20
    :associativity :left}
   ;; multiply
   {:regex-str "\\*"
    :precedence 19
    :associativity :left}
   ;; divide
   {:regex-str "\\/"
    :precedence 19
    :associativity :left}
   {:regex-str "/"
    :precedence 19
    :associativity :left}
   ;; mod
   {:regex-str "\\%"
    :precedence 19
    :associativity :left}
   {:regex-str "%"
    :precedence 19
    :associativity :left}
   ;; exp
   {:regex-str "\\^"
    :precedence 18
    :associativity :right}])

(defn gen-op-map [lexer]
  (let [regex-str-map (into {}
                            (for [[kw {:keys [regex-str]}] lexer]
                              [regex-str kw]))]
    (reduce
      (fn [m {:keys [regex-str] :as desc}]
        (if-let [sym (get regex-str-map regex-str)]
          (assoc m (parser/->terminal sym) desc)
          m))
      {}
      op-descs)))

(defn- edge-syms [raw path edges]
  (let [indices (reduce
                  (fn [acc [src dest]]
                    (into acc
                          (map first)
                          (find-edges raw src dest)))
                  []
                  edges)]
    (into []
          (map (partial get path))
          indices)))

(defn- classify-edges [raw]
  (letfn [(classifier [edge]
            (if (contains? elem-query-edges edge)
              :elem
              :other))]
    (let [query-edges (->> raw
                           (map last)
                           (partition 2 1))]
      (into []
            (map classifier)
            query-edges))))

(defn- extract-op
  "Return terminal if it is the only one in the RHS, otherwise nil"
  [production]
  (let [terminals (filter parser/terminal? (parser/rhs production))]
    (when (= (count terminals) 1)
      (first terminals))))

(defn- reconstruct-associativity
  "Return an associativity map for lhs-nt extracted from the given parser"
  [lhs-nt {{:keys [left right]} :associativities :as parser}]
  (let [xduce (comp (filter #(= (parser/lhs %) lhs-nt))
                    (map extract-op)
                    (keep identity))
        result (-> {}
                   (into (comp xduce (map #(vector % :left))) (uf/nodes left))
                   (into (comp xduce (map #(vector % :right))) (uf/nodes right)))]
    #_(console/debug ::reconstruct-associativity {:result result})
    result))

(defn- reconstruct-precedence
  "Return a precedence map for lhs-nt extracted from the given parser"
  [lhs-nt {{:keys [uf dag]} :priorities :as parser}]
  (let [order (into {}
                    (comp (filter #(= (parser/lhs %) lhs-nt))
                          (map-indexed #(vector %2 %1)))
                    (dag/topological-sort dag))
        next-precedence (inc (apply max 0 (vals order)))
        xform-set (fn [ps]
                    (into []
                          (comp (filter #(= (parser/lhs %) lhs-nt))
                                (map (fn [p]
                                       (when-let [o (extract-op p)]
                                         (if-let [precedence (get order (uf/find uf p))]
                                           [o precedence]
                                           [o next-precedence]))))
                                (keep identity))
                          ps))
        result (into {}
                     (mapcat xform-set)
                     (uf/->sets uf))]
    #_(console/debug :reconstruct-precedence {:result result})
    result))

(defn- init-associativity [lhs-nt op op-map parser]
  (let [existing (reconstruct-associativity lhs-nt parser)]
    (into existing
          (map #(vector % (get-in op-map [% :associativity])))
          (set/difference op (set (keys existing))))))

(defn- init-precedence [lhs-nt op op-map parser]
  (let [existing (reconstruct-precedence lhs-nt parser)]
    (into existing
          (map #(vector % (get-in op-map [% :precedence])))
          (set/difference op (set (keys existing))))))

(defn- -expression [constraint-state lexer parser]
  (let [all-syms (inference/all-syms constraint-state)
        -paired-syms (paired-syms lexer)
        left-syms (into #{} (map first -paired-syms))
        right-syms (into #{} (map second -paired-syms))
        op-map (gen-op-map lexer)
        -op-syms (set (keys op-map))
        elem-syms (set/difference all-syms
                                  left-syms
                                  right-syms
                                  -op-syms)
        query-state (-expression-query-state elem-syms
                                             -op-syms
                                             left-syms
                                             right-syms)
        query-result (run-query constraint-state query-state)
        lhs-nt (first (inference/extract-provenance-syms (:provenance constraint-state)))]
    #_(console/debug ::expression
                     {:elem-syms elem-syms
                      :op-syms -op-syms
                      :left-syms left-syms
                      :right-syms right-syms})
    (vec (for [{:keys [raw path]} (sort-by :raw query-result)
               :let [elem-nodes (edge-syms raw path elem-query-edges)
                     op-nodes (edge-syms raw path op-query-edges)
                     left-nodes (edge-syms raw path left-query-edges)
                     right-nodes (edge-syms raw path right-query-edges)
                     op (apply set/union op-nodes)
                     elem (apply set/intersection #{lhs-nt} elem-nodes)
                     paren (find-enclosing-pairs -paired-syms
                                                 (apply set/union left-nodes)
                                                 (apply set/union right-nodes))]
               :when (and (seq elem)
                          (seq op))]
           {:type :expression
            :raw raw
            :path path
            :params (merge {:lhs-nt lhs-nt
                            :op op
                            :associativity (init-associativity lhs-nt op op-map parser)
                            :precedence (init-precedence lhs-nt op op-map parser)
                            :classification (classify-edges raw)}
                           (when (seq paren)
                             {:paren paren}))}))))

(defn expression [constraint-state lexer parser]
  (limit-result (-expression constraint-state lexer parser)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; heuristic->productions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- ->temp-sym [kw]
  (let [s (name kw)]
    (if-not (.startsWith s "-")
      (keyword (str "-" s))
      kw)))

(defn ->permanent-sym [kw]
  (let [s (name kw)]
    (if (.startsWith s "-")
      (keyword (subs s 1))
      kw)))

(defn ->permanent-production [[lhs rhs :as production]]
  [(->permanent-sym lhs)
   (into [] (map ->permanent-sym) rhs)])

(defn heuristic->productions [{:keys [provenance] :as heuristic}]
  #_(console/debug ::heuristic->productions {:heuristic heuristic})
  (case (:type heuristic)
    :enclosed-delimited-list
    (let [{:keys [elem sep encloser]} (:params heuristic)
          lhs (first (inference/extract-provenance-syms provenance))
          lhs-inner (->temp-sym (str (name lhs) "-inner"))]
      [[lhs [(first encloser) lhs-inner (second encloser)]]
       [lhs-inner [elem]]
       [lhs-inner [elem sep lhs-inner]]])
    :enclosed-undelimited-list
    (let [{:keys [elem encloser]} (:params heuristic)
          lhs (first (inference/extract-provenance-syms provenance))
          lhs-inner (->temp-sym (str (name lhs) "-inner"))]
      [[lhs [(first encloser) lhs-inner (second encloser)]]
       [lhs-inner [elem]]
       [lhs-inner [elem lhs-inner]]])
    :delimited-list
    (let [{:keys [elem sep]} (:params heuristic)
          lhs (first (inference/extract-provenance-syms provenance))]
      [[lhs [elem]]
       [lhs [elem sep lhs]]])
    :undelimited-list
    (let [{:keys [elem]} (:params heuristic)
          lhs (first (inference/extract-provenance-syms provenance))]
      [[lhs [elem]]
       [lhs [elem lhs]]])
    :expression
    (let [{:keys [lhs-nt op paren]} (:params heuristic)
          binary-exprs (for [o op]
                         [lhs-nt [lhs-nt o lhs-nt]])
          paren-exprs (for [[l r] paren]
                        [lhs-nt [l lhs-nt r]])]
      (-> []
          (into binary-exprs)
          (into paren-exprs)))
    ;; default
    nil))

(defn- expression-heuristic->filters [heuristic]
  (let [{:keys [lhs-nt associativity precedence]} (:params heuristic)
        precedence-groups (->> precedence
                               (group-by second)
                               (sort-by first)
                               (vals)
                               (map (partial map first)))
        assocs (vec (for [op-syms precedence-groups]
                      {:type :associativity
                       :direction (get associativity (first op-syms))
                       :productions (into []
                                          (map (fn [sym]
                                                 [lhs-nt [lhs-nt sym lhs-nt]]))
                                          (sort op-syms))}))
        prios (vec (for [[high low] (partition 2 1 assocs)]
                     {:type :priority
                      :high (first (:productions high))
                      :low (first (:productions low))}))]
    (into assocs prios)))

(defn heuristic->filters [heuristic]
  (case (:type heuristic)
    :expression (expression-heuristic->filters heuristic)
    ;; default
    nil))
